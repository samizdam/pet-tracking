устройство отправляет сообщения (назовем их пакеты) с навигационными данными и данными об активности

    пакеты могут дублироваться
    пакеты могут прийти не в хронологическом порядке

авторизационные данные находятся в заголовке HTTP, payload в теле сообщения, все как обычно
существует 2 вида пакетов:
пакет "Трек" содержит поля:

    int8 статус устройства
    int32 таймстамп в UTC
    floаt "lat" широта в градусах
    float "lon" долгота в градусах
    int8 высота в метрах
    int8 "accu" точность в метрах

пакет "Активность" содержит поля:

    int8 статус устройства
    int32 таймстамп в UTC
    int8 тип активности (0 - сон,1 - шаг,3 - галоп,6 - рысь,255 - шаги не измеряются)
    int кол-во шагов

эти пакеты отправляются независимо. пакеты "трек" отправляются только когда устройство в режиме прогулки. пакеты активность отправляются почти всегда
необходимо описать алгоритм работы (втч можно использовать псевдокод, блок-схемы), применяемые технологии, архитектурные и инфраструктурные решения, решения для задачи обработки поступающих пакетов
сервис должен уметь:

    отсеивать дублирующиеся пакеты (по типу пакета и timestamp)
    отдавать последнюю координату устройства
    отдавать текущие координаты устройств внутри определенного bounding box
    сохранять и агрегировать статистику по активности, отдельно вычислять активность которая была в рамках записи трека
    отправлять пуш уведомления при изменения статус устройства
    описать алгоритм работы подсистемы, вычисляющей совместные прогулки

совместные прогулки
прогулка является совместной если 2 устройства находились рядом (на расстоянии до 6 метров) в течение N минут (N=10), вычисления производятся на основе данных трека (координаты и timestamp) стоит обратить внимание:

    совместная прогулка может содержать более 2х устройств, необходимо вычислять пары прогулок для каждого из устройств
    совместная прогулка может прерываться и возобновляться в рамках одного трека (гуляли-разошлись-потом опять встретились)
    совместная прогулка одного устройства, может пересекаться с N совместных прогулок другого устройства
    нет гарантии что треки попадают на сервер сразу (например, устройство одного участника загружает трек сразу, а устройство другого участника через 8 часов), продумать механизм дообсчета "старых" треков


* _отсеивать дублирующиеся пакеты (по типу пакета и timestamp)_ - реализовано в прототипе, ответ со статусом 409
* _отдавать последнюю координату устройства_ - реализовано в прототипе, введена сущность Устройства (Device)
* _отдавать текущие координаты устройств внутри определенного bounding box_ - для эффективной работы с гео-данными стоит выбрать для хранения не простой float, а специальное расширение, либо РСУБД с поддержкой соответетсвующих типов данных. Такие решения есть и для Mysql (https://dev.mysql.com/doc/refman/8.0/en/spatial-geohash-functions.html) и для Postgres (https://postgis.net/features/)
* _сохранять и агрегировать статистику по активности, отдельно вычислять активность которая была в рамках записи трека_ - решение в лоб, сохранять связь Активности с последним полученным Треком Устройства. Либо агрегировать данные в фоне на основе последовательности timestamp. Детали зависят от того что подразумевается под "статистикой", и какие операции над агрегированными данными нужны
* _отправлять пуш уведомления при изменения статус устройства_ - вероятно имеются в виду push-уведомления для каких-то операционных систем. У разных вендоров есть сервисы для интеграции. Так же есть программные библиотеки облегчающие подобную интеграцию. В случае, если событие приводящее к отправке уведомления инициируется в момент обработки запроса HTTP (который синхронен), стоит рассмотреть отправку событий для уведомлений через асинхронную шину, чтобы в случае проблем с внешним сервисом не было блокировки обработки HTTP-запроса
* _описать алгоритм работы подсистемы, вычисляющей совместные прогулки_ - следует ввести сущность Прогулка. Прогулка имеет начало и конец во времени, включает множество Трек и Активностей, ссылку на Устройство. Совместные Прогулки - те которые удовлетворяют описанным условиям. Надо детально продумать структуру данных, и составить запросы к ней. Расчёт производится в фоне. 


_Для упрощения реализации, принято, что идентификатором устройства служит значение переданное в заголовке `Authorization`._
 
